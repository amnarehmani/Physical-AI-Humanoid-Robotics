---
id: 03-lesson-3
title: "The Digital Mirror"
sidebar_label: "3. Unity Digital Twin"
description: "Visualizing the robot in Unity using ROS-TCP-Connector for high-fidelity rendering."
keywords:
  - unity
  - digital twin
  - ros-tcp
  - visualization
---

# Lesson 3: The Digital Mirror (Unity)

## 1. Introduction

We have built a body (URDF), a brain (ROS 2), and a physics world (Gazebo). But our simulation is still visually crude. Gazebo focuses on math, not aesthetics.

For **Human-Robot Interaction (HRI)** and **Vision-Based Learning**, we need photorealism. We need to see shadows, reflections, and realistic textures. We need **Unity**.

In this final lesson of Module 2, we will build the "Digital Mirror"—connecting our rigorous physics simulation to a beautiful game engine visualization. This setup allows us to train vision models on synthetic data that looks almost real.

## 2. Conceptual Understanding: The Visualization Layer

Why don't we just do physics in Unity?
Unity uses **PhysX**, a game physics engine optimized for stability and speed, not accuracy. It often "cheats" to keep frame rates high.
Gazebo uses **DART/ODE**, optimized for accuracy.

So we split the responsibilities:
*   **Gazebo**: The "Server" of truth. Calculates where the robot *actually* is.
*   **Unity**: The "Client" of beauty. Renders the robot where Gazebo says it is.

This requires a high-speed data link. Since Unity often runs on Windows (for graphics drivers) and ROS on Linux, we connect them via **TCP/IP**.

## 3. System Perspective: The Network Bridge

We introduce a new component: the **ROS-TCP-Endpoint**.

```text
[ Linux Machine (ROS 2) ]                 [ Windows Machine (Unity) ]
+-----------------------+                 +-------------------------+
|                       |    TCP / IP     |                         |
|   /cmd_vel (Topic)  --+---------------->+-- [ROS-TCP-Connector] |
|                       |    JSON/BSON    |           |             |
| [ROS-TCP-Endpoint]    |                 |      [Deserializer]     |
|                       |                 |           |             |
|   /image (Topic)    <+------------------+-- [Virtual Camera]      |
|                       |                 |                         |
+-----------------------+                 +-------------------------+
```

1.  **ROS-TCP-Endpoint**: A ROS node that acts as a server. It serializes ROS messages into JSON/BSON.
2.  **ROS-TCP-Connector**: A Unity script that connects to the endpoint, deserializes the data, and triggers C# events.

## 4. Implementation: Setting Up Unity

### 4.1 Installation
1.  Install **Unity Hub** and **Unity 2021.3+ (LTS)**.
2.  Create a new **3D Core** project.
3.  Open `Window` -> `Package Manager`.
4.  Click `+` -> `Add package from git URL`.
5.  Enter: `https://github.com/Unity-Technologies/ROS-TCP-Connector.git?path=/com.unity.robotics.ros-tcp-connector`

### 4.2 The Robot Controller Script
We need a C# script to listen to ROS messages and move the Unity GameObject.

Create `code/module-2/unity_scripts/RobotController.cs`:

```csharp
using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Geometry; // Generated by Unity Robotics Hub

public class RobotController : MonoBehaviour
{
    public string topicName = "/cmd_vel";
    
    void Start()
    {
        // 1. Get the ROS Connection
        ROSConnection ros = ROSConnection.GetOrCreateInstance();
        
        // 2. Subscribe to the Topic
        // We tell Unity: "When you get a TwistMsg on this topic, call MoveRobot()"
        ros.Subscribe<TwistMsg>(topicName, MoveRobot);
    }

    void MoveRobot(TwistMsg msg)
    {
        // 3. Map ROS Coordinates (Right-Handed) to Unity (Left-Handed)
        // ROS: X=Forward, Y=Left, Z=Up
        // Unity: Z=Forward, X=Right, Y=Up
        
        // Linear Velocity (Forward/Backward)
        // ROS X -> Unity Z
        float linearSpeed = (float)msg.linear.x;

        // Angular Velocity (Turning)
        // ROS Z (Yaw) -> Unity Y (Yaw)
        // Note: Coordinate system handover requires negative sign for rotation
        float angularSpeed = -(float)msg.angular.z;

        // 4. Apply Movement
        // Translate along Z axis
        transform.Translate(Vector3.forward * linearSpeed * Time.deltaTime);
        
        // Rotate around Y axis
        transform.Rotate(Vector3.up, angularSpeed * Mathf.Rad2Deg * Time.deltaTime);
    }
}
```

## 5. Real-World Example: Sim-to-Real Transfer

OpenAI used this exact technique to teach a robotic hand to solve a Rubik's Cube.
They simulated the hand in Unity with randomized lighting, textures, and physics parameters (called **Domain Randomization**).
Because the AI saw millions of variations in Unity—red lights, blue lights, slippery cubes, sticky cubes—it learned to be robust. When they turned it on in the real world, it "just worked."

If they had trained only in a grey Gazebo world, the AI would have failed the moment a shadow fell across the cube.

## 6. Engineering Insights: Coordinate Hell

The biggest pain point in Digital Twins is **Coordinate Systems**.
*   **ROS**: Right-Handed (X-Forward, Z-Up).
*   **Unity**: Left-Handed (Z-Forward, Y-Up).
*   **Unreal**: Left-Handed (X-Forward, Z-Up).

If you simply pipe `x,y,z` from ROS to Unity, your robot will drive sideways and rotate backwards.
**Best Practice**: Always use a wrapper script (like `RobotController.cs`) to explicitly map axes. Never assume `x=x`.

## 7. Summary

We have completed Module 2. We now have a full **Digital Twin Pipeline**:
1.  **Physics**: Gazebo simulates the forces.
2.  **Sensing**: Gazebo Plugins generate LiDAR and IMU data.
3.  **Visualization**: Unity renders the scene and can simulate cameras.
4.  **Control**: ROS 2 orchestrates it all.

You now possess the infrastructure used by top robotics companies. In Module 3, we will give this robot a brain capable of mapping and navigating this world.
