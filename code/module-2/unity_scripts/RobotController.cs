using UnityEngine;
using Unity.Robotics.ROSTCPConnector;
using RosMessageTypes.Geometry; // Generated by Unity Robotics Hub

public class RobotController : MonoBehaviour
{
    public string topicName = "/cmd_vel";
    
    void Start()
    {
        // 1. Get the ROS Connection
        ROSConnection ros = ROSConnection.GetOrCreateInstance();
        
        // 2. Subscribe to the Topic
        // We tell Unity: "When you get a TwistMsg on this topic, call MoveRobot()"
        ros.Subscribe<TwistMsg>(topicName, MoveRobot);
    }

    void MoveRobot(TwistMsg msg)
    {
        // 3. Map ROS Coordinates (Right-Handed) to Unity (Left-Handed)
        // ROS: X=Forward, Y=Left, Z=Up
        // Unity: Z=Forward, X=Right, Y=Up
        
        // Linear Velocity (Forward/Backward)
        // ROS X -> Unity Z
        float linearSpeed = (float)msg.linear.x;

        // Angular Velocity (Turning)
        // ROS Z (Yaw) -> Unity Y (Yaw)
        // Note: Coordinate system handover requires negative sign for rotation
        float angularSpeed = -(float)msg.angular.z;

        // 4. Apply Movement
        // Translate along Z axis
        transform.Translate(Vector3.forward * linearSpeed * Time.deltaTime);
        
        // Rotate around Y axis
        transform.Rotate(Vector3.up, angularSpeed * Mathf.Rad2Deg * Time.deltaTime);
    }
}
